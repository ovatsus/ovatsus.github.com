---
layout: post
title: "Introducing PreSharp"
date: 2011-10-02
comments: true
categories: [PreSharp, Code Generation]
---
<h3>Background</h3>  <p>Back in 2004, I was doing some code-generation work as part of the <a href="http://www.gsd.inesc-id.pt/project-pages/past-projects/obiwan">OBIWAN</a> project. When I started, CodeDom was being used to do the work, but I really didn’t like it because it made the generator code very hard to read and modify. Realistically, I would not need to support any other language than C#, so I started looking for alternatives. <a href="http://www.codesmithtools.com/product/generator">CodeSmith</a> was very popular at the time for generating type-safe collections (.NET 2.0 generics didn’t exist yet), but it was targeted at one-shot generations, and not at creating code generation code. Then I found a very simple tool named <a href="http://web.archive.org/web/20060726075638/http://www.inmetrix.com/">CodeGen</a> that appealed to me. I had been playing around with the <a href="http://www.boost.org/doc/libs/?view=category_Preprocessor">Boost Preprocessor library</a> recently, so I really liked the idea of using the preprocessor. I did a few tweaks to it and was able to use it for my needs at the time. Later on, around mid-2007, I needed to do code-generation again, so I took this tool and added a good amount of more power to it. At this time, it was very far apart from the original code, so I re-baptized it as PreSharp and published it to CodePlex. I never got around to do any documentation for it, so I’m making this post to try to compensate for that. I also moved the project recently from CodePlex to <a href="https://github.com/ovatsus/PreSharp">GitHub</a>.</p>
<!-- more -->
<h3>PreSharp as a C# Preprocessor</h3>  <p>Let’s say we’re using .NET 2.0 which doesn’t have the Func&lt;&gt; delegates and we want to define our own: </p>
{% codeblock lang:csharp %}
public delegate TResult Func<TResult>();
public delegate TResult Func<T1, TResult>(T1 arg1);
public delegate TResult Func<T1, T2, TResult>(T1 arg1, T2 arg2);
public delegate TResult Func<T1, T2, T3, TResult>(T1 arg1, T2 arg2, T3 arg3);
{% endcodeblock %}

<p>This gets tedious really quickly, so let’s use PreSharp to generate this for us:</p>

{% codeblock lang:csharp %}
#if PRESHARP_TEMPLATE
<% for (int i = 0; i <= 10; ++i) { %>
public delegate TResult Func<<%
       for (int j = 1; j <= i; ++j) { %>T<%= j %>, <% }
                                 %>TResult>(<%
       for (int j = 1; j <= i; ++j) { %><%= j == 1 ? string.Empty : ", " %>T<%= j %> arg<%= j %><% }
                                                %>);
<% } %>
#endif
{% endcodeblock %}

<p align="left">Now if we run <a href="https://github.com/downloads/ovatsus/PreSharp/PreSharp.exe">PreSharp.exe</a> &lt;file.cs&gt;, that region of code will be turned into this:</p>

{% codeblock lang:csharp %}
#if PRESHARP_TEMPLATE
<% for (int i = 0; i <= 5; ++i) { %>
public delegate TResult Func<<%
       for (int j = 1; j <= i; ++j) { %>T<%= j %>, <% }
                                 %>TResult>(<%
       for (int j = 1; j <= i; ++j) { %><%= j == 1 ? string.Empty : ", " %>T<%= j %> arg<%= j %><% }
                                                %>);
<% } %>
#else
#region PreSharp Generated

public delegate TResult Func<TResult>();

public delegate TResult Func<T1, TResult>(T1 arg1);

public delegate TResult Func<T1, T2, TResult>(T1 arg1, T2 arg2);

public delegate TResult Func<T1, T2, T3, TResult>(T1 arg1, T2 arg2, T3 arg3);

public delegate TResult Func<T1, T2, T3, T4, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);

public delegate TResult Func<T1, T2, T3, T4, T5, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);

#endregion
#endif
{% endcodeblock %}

<p>So, the syntax is similar to ASP.NET, similarly to most template based code generators: code between &lt;% and %&gt; is executed; code between &lt;%= and %&gt; is evaluated as an expression; and the rest of the code is dumped to the output directly.</p>

<h3>PreSharp as a Source Code Generator Generator</h3>

<p>The real power of PreSharp comes when instead of PRESHARP_TEMPLATE we use PRESHARP_TEMPLATE_LIBRARY. In this case the output after running PreSharp will be the following:</p>

{% codeblock lang:csharp %}
#if PRESHARP_TEMPLATE_LIBRARY
<% for (int i = 0; i <= 10; ++i) { %>
public delegate TResult Func<<%
       for (int j = 1; j <= i; ++j) { %>T<%= j %>, <% }
                                 %>TResult>(<%
       for (int j = 1; j <= i; ++j) { %><%= j == 1 ? string.Empty : ", " %>T<%= j %> arg<%= j %><% }
                                                %>);
<% } %>
#else
#region PreSharp Generated
   for (int i = 0; i <= 10; ++i) {     writer.Write("\r\n");
  writer.Write("public delegate TResult Func<");
       for (int j = 1; j <= i; ++j) {         writer.Write("T");writer.Write( j );  writer.Write(", "); }
                                   writer.Write("TResult>(");
       for (int j = 1; j <= i; ++j) {         writer.Write( j == 1 ? string.Empty : ", " );writer.Write("T");writer.Write( j );writer.Write(" arg");writer.Write( j );   }
                                                    writer.Write(");\r\n");
   } writer.Write("\r\n");
#endregion
#endif
{% endcodeblock %}

<p>So if we use this in a context were we have an object named <strong>writer</strong> with a method <strong>Write</strong> that accepts a string, it will generate the code for generating the code at runtime. It’s ugly code, but it does the job, and we can collapse all the #region PreSharp Generated blocks. If instead of <strong>writer</strong>, we have a variable named something else, we can suffix the #if directive with _variableName. For example, if we want <strong>output</strong> as the variable name, we’ll use PRESHARP_TEMPLATE_LIBRARY_output.</p>

<h3>Visual Studio Integration</h3>

<p>To setup the Visual Studio integration of PreSharp we just need to run it once without parameters. It will copy itself to C:\Program Files (x86)\PreSharp, customize MSBuild Custom.After.Microsoft.Common.targets and set some Visual Studio settings in the registry.</p>

<p>After this is setup, instead of running PreSharp.exe manually, we can just change the build action of the relevant files in Visual Studio from Compile to <strong>PreSharpInplace</strong>. This will make sure PreSharp is run before the compilation phase.</p>

<p>When there is any error in the code inside a PreSharp block, the errors will be displayed in the Visual Studio errors pane, next to the compilation errors, and we can double click them to go to the correct location. In some cases PreSharp fails the column number by a few characters, but the line number is always right.</p>

<p>As this is implemented through MSBuild tasks, it will also work in command line builds. Some other tools use Custom Tools that only work inside Visual Studio (but which have other advantages, like&#160; being able to display generated files below the source file in Solution Explorer).</p>

<h3>Reusing code</h3>

<p>Each PreSharp block is compiled independently of each other. If we need to share code, we must put it in separate files and set the build action to <strong>PreSharpTemplateLibrary</strong>. Then all public classes of those files will be available inside normal PreSharp template blocks. Additionally, you can also use directives inside template blocks to import namespaces and to reference assemblies, by using <strong>&lt;%@ Import Namespace=&quot;NamespaceToImport&quot; %&gt;</strong> and <strong>&lt;%@ Assembly Name=&quot;AssemblyToReference&quot; %&gt;</strong>.</p>

<p>Let’s rewrite our example to take advantage of these features. We’ll add a file StringUtils.cs with the build action set to <strong>PreSharpTemplateLibrary</strong>:</p>

{% codeblock lang:csharp %}
using System.Collections.Generic;
using System.Text;

public static class StringUtils {

    public static string StrCat(this IEnumerable<string> source, string separator) {
        var sb = new StringBuilder();
        bool first = true;
        foreach (string elem in source) {
            if (first) {
                first = false;
            } else {
                sb.Append(separator);
            }
            sb.Append(elem);
        }
        return sb.ToString();
    }
}
{% endcodeblock %}

<p>And then change the original PreSharp block to this:</p>

{% codeblock lang:csharp %}
#if PRESHARP_TEMPLATE
<%@ Assembly Name="System.Core" %>
<%@ Import Namespace="System.Linq" %>
<% for (int i = 0; i <= 5; ++i) { 
    var range = Enumerable.Range(1, i); %>
public delegate TResult Func<<%= range.Select(ii => "T" + ii + ", ")
                                      .StrCat("") %>TResult>(<%= range.Select(ii => "T" + ii + " arg" + ii)
                                                                      .StrCat(", ") %>);
<% } %>
#endif
{% endcodeblock %}

<p>In the <strong>Assembly</strong> directive you can specify the full path of an assembly (and in that case don’t forget to include the .dll at the end), or if that assembly is referenced by the Visual Studio project you can just specify the assembly name. PreSharp takes advantage of part of the MSBuild processing to find the file path.</p>

<p>In order for Visual Studio IntelliSense to work properly, StringUtils will be compiled into your assembly in debug builds, but it release builds it won’t, as this code is only meant to be used in your PreSharp blocks.</p>

<h3>Generating files</h3>

<p>Instead of generating code in-place in a C# file, PreSharp can also be used to define code that will be called at compile time to output additional files to the project. For that, we will use a new build action - <strong>PreSharpTemplate</strong>. Here’s an example:</p>

<p>File ViewModelGenerator.cst with build action set to <strong>PreSharpTemplate</strong>:</p>

{% codeblock lang:csharp %}
#if PRESHARP_TEMPLATE
<%@ CodeTemplate Language="C#" TargetLanguage="C#" %>
<%@ Assembly Name="System.Core" %>
<%@ Assembly Name="System.Xml" %>
<%@ Assembly Name="System.Xml.Linq" %>
<%@ Include Path="ViewModelDefinition.cst" %>
<%@ EntryPoint Statement="CodeGeneration.ViewModelGenerator.Generate();" %>
#endif

using System.Xml.Linq;

namespace CodeGeneration {

    class ViewModelGenerator {

        public static void Generate() {
            foreach (var viewXml in XElement.Load("ViewModel.xml").Elements("view")) {
                var view = new View { 
                    Name = viewXml.Attribute("name").Value,
                };
                foreach (var propertyXml in viewXml.Elements("property")) {
                    view.Properties.Add(new Property {
                        PropertyName = propertyXml.Attribute("name").Value,
                        Type = propertyXml.Attribute("type").Value,
                    });
                }
                view.Dump();
            }
        }
    }
}
{% endcodeblock %}

<p>File ViewModel.xml with build action set to <strong>PreSharpInput</strong>:</p>

{% codeblock lang:xml %}
<viewModel>
    <view name="View1">
        <property name="Property1" type="string" />
        <property name="Property2" type="int" />
    </view>
    <view name="View2">
        <property name="Property" type="bool" />
    </view>
</viewModel>
{% endcodeblock %}

<p>File ViewModelDefinition.cst with build action set to <strong>PreSharpTemplateInclude</strong>:</p>

{% codeblock lang:csharp %}
#if PRESHARP_TEMPLATE
<%@ Import Namespace="System.Collections.Generic" %>
#endif

namespace CodeGeneration {

    class Property {
        public string PropertyName { get; set; }
        public string FieldName { get { return PropertyName.ToLower(); } }
        public string Type { get; set; }
    }

    class View {
        public string Name { get; set; }
        public List<Property> Properties = new List<Property>();

        public void Dump() {
#if PRESHARP_TEMPLATE
<% PreSharp.SetOutput(Name + ".Generated.cs", PreSharp.OutputType.Compile); %>

public class <%= Name %> : ViewModelBase {

#endif
            foreach (var p in Properties) {
#if PRESHARP_TEMPLATE

    private <%= p.Type %> <%= p.FieldName %>;
    public <%= p.Type %> <%= p.PropertyName %> {
        get { return <%= p.FieldName %>; }
        set { if (<%= p.FieldName %> != value) { <%= p.FieldName %> = value; RaiseNotify("<%= p.PropertyName %>"); } }
    }

#endif
            }
#if PRESHARP_TEMPLATE

}

#endif
        }
    }
}
{% endcodeblock %}

<p>Let me explain how this works:</p>

<ul>
  <li>The file with the build action set to <strong>PreSharpTemplate</strong> must specify directive with the format <strong>&lt;%@ EntryPoint Statement=&quot;codeToExecute();&quot; %&gt;</strong> to tell PreSharp what code to execute at compile time. That code can call PreSharp.SetOutput(string filename, PreSharp.OutputType outputType) inside the blocks to set the output file (OutputType is an enum with the values <strong>Compile</strong>, <strong>EmbeddedResource</strong>, and <strong>None</strong>). From that point on, the code generated by the PreSharp blocks will be written to that file, and that file will be added to the Visual Studio project with the corresponding build action. </li>

  <li>The build action <strong>PreSharpTemplateInclude</strong> and the associated <strong>&lt;%@ Include Path=&quot;path&quot; %&gt;</strong> directive allow you to split generators in multiple files. If you just have multiple files with PreSharpTemplate build action they will all be handled independently.</li>

  <li>In the examples I uses the extension .cst but in reality it could be anything. When PreSharp is installed it registers .cst in Visual Studio as a c# file, so you can use that extension and still have syntax highlighting. </li>

  <li>The build action <strong>PreSharpInput</strong> informs PreSharp that whenever that file is changed, it should regenerate the target files. </li>

  <li>The <strong>&lt;%@ CodeTemplate Language=&quot;C#&quot; TargetLanguage=&quot;C#&quot; %&gt; </strong>directive is ignored, and it’s only supported to allow compatibility with CodeSmith so you can edit these files in its editor and have syntax highlighting.</li>
</ul>

<h3>Debugging</h3>

<p>When PreSharp executes the templates in the previous example, it generates a file named ViewModelGenerator.cst.PreSharpDebug.cs. If you want to debug the template execution, you can create a new C# project that includes this file, references C:\Program Files (x86)\PreSharp\PreSharp.exe as an assembly, and then put the contents of the Entry directive as the Main method. When running this project you can step by step the execution of the template.</p>

<h3>Known Problems</h3>

<p>I’ve been using PreSharp for a few years in real-life production software, so it’s pretty stable and efficient by now. But there is still one very annoying problem with it. If you have a generated file open and then build the project and that file is changed, Visual Studio will wrongly use the cache of the previous content of the file in the compilation, and your build output will be wrong. At OutSystems we call this the “double build syndrome”. If you don’t have that file open, or if you’re building directly with MSBuild on a command shell or on a build server, it all works correctly, so it’s really a Visual Studio bug.</p>

<p>Aside from this post (which I should have done three years ago when I first created the blog), there is currently no other documentation for PreSharp, so feel free to ask any question through a comment here or through the GitHub project page.</p>
