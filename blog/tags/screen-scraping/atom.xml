<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Screen Scraping | Code Beside]]></title>
  <link href="http://blog.codebeside.org/blog/tags/screen-scraping/atom.xml" rel="self"/>
  <link href="http://blog.codebeside.org/"/>
  <updated>2013-11-10T21:52:34+00:00</updated>
  <id>http://blog.codebeside.org/</id>
  <author>
    <name><![CDATA[Gustavo Guerra]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[F# for Screen Scraping]]></title>
    <link href="http://blog.codebeside.org/blog/2013/10/14/fsharp-for-screen-scraping"/>
    <updated>2013-10-14T23:58:00+01:00</updated>
    <id>http://blog.codebeside.org/blog/2013/10/14/fsharp-for-screen-scraping</id>
    <content type="html"><![CDATA[<p>One of the many things F# is great for is screen scraping. Here's why:</p>

<ul>
<li>Downloading multiple pages asynchronously and in parallel is trivial with F#'s async support</li>
<li>Navigating the HTML DOM is a great fit for higher order data processing combined with partial application</li>
<li>F# Interactive really shines in iterative processes like this, where you try something out, see it didn't work quite well, and keep adjusting until you get it right. Doing a full compile-run cycle on each iteration instead of simply evaluating in the REPL would make this task take much more time-consuming</li>
</ul>


<p><a href="http://htmlagilitypack.codeplex.com/">Html Agility Pack</a> is the obvious candidate to use for screen scraping in .NET, but like other LINQ-like libraries that rely heavily on extension methods, its API isn't ideal for use in F#. A simple wrapper will take care of that problem:</p>

<!-- More -->


<p>{% codeblock lang:fsharp An F# wrapper for HtmlAgilityPack - HtmlAgilityPack.FSharp.fs %}
module HtmlAgilityPack.FSharp</p>

<p>open HtmlAgilityPack</p>

<p>type HtmlNode with</p>

<pre><code>member x.FollowingSibling name = 
    let sibling = x.NextSibling
    if sibling = null then
        null
    elif sibling.Name = name then
        sibling
    else 
        sibling.FollowingSibling name

member x.FollowingSiblings name = seq {
    let sibling = x.NextSibling
    if sibling &lt;&gt; null then
        if sibling.Name = name then
            yield sibling
        yield! sibling.FollowingSiblings name
}

member x.PrecedingSibling name = 
    let sibling = x.PreviousSibling
    if sibling = null then
        null
    elif sibling.Name = name then
        sibling
    else 
        sibling.PrecedingSibling name

member x.PrecedingSiblings name = seq {
    let sibling = x.PreviousSibling
    if sibling &lt;&gt; null then
        if sibling.Name = name then
            yield sibling
        yield! sibling.PrecedingSiblings name
}
</code></pre>

<p>let parent (node : HtmlNode) =</p>

<pre><code>node.ParentNode
</code></pre>

<p>let element name (node : HtmlNode) =</p>

<pre><code>node.Element name
</code></pre>

<p>let elements name (node : HtmlNode) =</p>

<pre><code>node.Elements name
</code></pre>

<p>let descendants name (node : HtmlNode) =</p>

<pre><code>node.Descendants name
</code></pre>

<p>let descendantsAndSelf name (node : HtmlNode) =</p>

<pre><code>node.DescendantsAndSelf name
</code></pre>

<p>let ancestors name (node : HtmlNode) =</p>

<pre><code>node.Ancestors name
</code></pre>

<p>let ancestorsAndSelf name (node : HtmlNode) =</p>

<pre><code>node.AncestorsAndSelf name
</code></pre>

<p>let followingSibling name (node : HtmlNode) =</p>

<pre><code>node.FollowingSibling name
</code></pre>

<p>let followingSiblings name (node : HtmlNode) =</p>

<pre><code>node.FollowingSiblings name
</code></pre>

<p>let precedingSibling name (node : HtmlNode) =</p>

<pre><code>node.PrecedingSibling name
</code></pre>

<p>let precedingSiblings name (node : HtmlNode) =</p>

<pre><code>node.PrecedingSiblings name
</code></pre>

<p>let inline innerText (node : HtmlNode) =</p>

<pre><code>node.InnerText
</code></pre>

<p>let inline attr name (node : HtmlNode) =</p>

<pre><code>node.GetAttributeValue(name, "")
</code></pre>

<p>let inline (?) (node : HtmlNode) name =</p>

<pre><code>attr name node
</code></pre>

<p>let inline hasAttr name value node =</p>

<pre><code>attr name node = value
</code></pre>

<p>let inline hasId value node =</p>

<pre><code>hasAttr "id" value node
</code></pre>

<p>let inline hasClass value node =</p>

<pre><code>hasAttr "class" value node
</code></pre>

<p>let inline hasText value (node : HtmlNode) =</p>

<pre><code>node.InnerText = value
</code></pre>

<p>let createDoc html =</p>

<pre><code>let doc = new HtmlDocument()
doc.LoadHtml html
doc.DocumentNode
</code></pre>

<p>{% endcodeblock %}</p>

<p>When we leave the "target" of an operation as the last parameter of a function, we can leverage partial application to remove the need to create anonymous lambdas when using higher order functions such as the ones needed for DOM traversing.</p>

<p>In this case, by taking the <code>this</code> parameter of the C# methods and putting it as the last parameter of our wrapper functions <code>elements</code>, <code>descendants</code>, <code>innerText</code>, etc., our code is now much easier to read and to understand than if we used the Html Agility Pack methods directly.</p>

<p>As an example, here is a small script that I used when developing one of my Windows Phone apps to get the list if all the rail stations in Ireland together with their coordinates:</p>

<p>{% codeblock lang:fsharp IrelandRailStations.fsx %}</p>

<h1>r "System.Net"</h1>

<h1>r "../lib/portable/FSharp.Data.dll"</h1>

<h1>r "../packages/HtmlAgilityPack-PCL.1.4.6/lib/HtmlAgilityPack-PCL.dll"</h1>

<h1>load "HtmlAgilityPack.FSharp.fs"</h1>

<p>// get a page that lists the stations that start with firstLetter
let getStationListPage firstLetter =</p>

<pre><code>"http://www.irishrail.ie/cat_stations_list.jsp?letter=" + (string firstLetter)
|&gt; Http.AsyncRequestString
</code></pre>

<p>// get all the links to stations inside the <ul class="results">
let getStations stationListPage =</p>

<pre><code>stationListPage
|&gt; createDoc
|&gt; descendants "ul"
|&gt; Seq.filter (hasClass "results")
|&gt; Seq.head
|&gt; descendants "a"
|&gt; Seq.map (attr "href")
|&gt; Seq.toArray
</code></pre>

<p>// get the page for a station
let getStationPage station =</p>

<pre><code>"http://www.irishrail.ie/" + station
|&gt; Http.AsyncRequestString
</code></pre>

<p>// get the latitude and longitude of a station from the google maps link in the station page
let getCoordinates stationPage =</p>

<pre><code>let googleMapsLink = 
    stationPage
    |&gt; createDoc
    |&gt; descendants "div"
    |&gt; Seq.filter (hasId "map-ordnance")
    |&gt; Seq.head
    |&gt; followingSibling "ul"
    |&gt; descendants "a"
    |&gt; Seq.head
    |&gt; attr "href"
let split (c:char) (s:string) = s.Split c
let [| "ll" ; coords |] =        
    Uri(googleMapsLink).Query
    |&gt; split '&amp;'
    |&gt; Seq.map (split '=')
    |&gt; Seq.filter (Seq.head &gt;&gt; (=) "ll")
    |&gt; Seq.head
let [| lat; long |] = coords |&gt; split ',' |&gt; Array.map float
lat, long
</code></pre>

<p>let stationsAndCoords =</p>

<pre><code>let stations = 
    ['A'..'Z'] 
    |&gt; Seq.map getStationListPage
    |&gt; Async.Parallel
    |&gt; Async.RunSynchronously
    |&gt; Array.collect getStations
let lat, long = 
    stations
    |&gt; Seq.map getStationPage
    |&gt; Async.Parallel
    |&gt; Async.RunSynchronously
    |&gt; Array.map getCoordinates
    |&gt; Array.unzip
let stations = 
    stations
    |&gt; Array.map Uri.UnescapeDataString
Array.zip3 stations lat long
</code></pre>

<p>{% endcodeblock %}</p>

<p>Output:</p>

<p>{% codeblock lang:fsharp %}
val stationsAndCoords : (string * float * float) [] =
  [|("Adamstown", 53.335285, -6.4523325); ("Ardrahan", 53.157177, -8.814831);</p>

<pre><code>("Arklow", 52.793163, -6.159939); ("Ashtown", 53.37552, -6.3313503);
("Athenry", 53.30153, -8.748547); ("Athlone", 53.427322, -7.9368286);
("Athy", 52.991997, -6.976196); ("Attymon", 53.321205, -8.606078);
...|]
</code></pre>

<p>{% endcodeblock %}</p>

<p>You can also see that the same pattern was used for making the <code>String.Split</code> function play well with partial application.</p>

<p>Another neat feature of F# for scripting (I wouldn't recommend incorporating it in production code), is the ability to de-structure arrays in one liners, as done in <code>let [| "ll" ; coords |] =</code> and <code>let [| lat; long |] =</code>. The compiler will emit a warning saying that the match is not exhaustive, telling us that this might backfire if there are less than two elements in the array, but for the purpose of a one shot script to download some data it's fine.</p>

<p>And to give a second example, here's a snippet from my Learn On The Go app that processes the html of the lecture videos page of a Coursera course:</p>

<p>{% codeblock lang:fsharp %}
let lectureSections =</p>

<pre><code>let trimAndUnescape (text:string) = text.Replace("&amp;nbsp;", "").Trim().Replace("&amp;amp;", "&amp;").Replace("&amp;quot;", "\"").Replace("apos;", "'").Replace("&amp;lt;", "&lt;").Replace("&amp;gt;", "&gt;")
let endsWith suffix (text:string) = text.EndsWith suffix
createDoc lecturesHtmlStr
|&gt; descendants "h3"
|&gt; Seq.map (fun h3 -&gt;
    let title = h3 |&gt; innerText |&gt; trimAndUnescape
    let completed = h3 |&gt; parent |&gt; hasClass "course-item-list-header contracted"
    let ul = 
        h3 
        |&gt; parent
        |&gt; followingSibling "ul"
    ul, title, completed)
|&gt; Seq.filter (fun (ul, _, _) -&gt; ul &lt;&gt; null)
|&gt; Seq.map (fun (ul, title, completed) -&gt; 
    let lectures =
        ul
        |&gt; elements "li"
        |&gt; Seq.map (element "a")
        |&gt; Seq.map (fun a -&gt;
            let id = a |&gt; attr "data-lecture-id" |&gt; int
            let title = innerText a |&gt; trimAndUnescape
            let quizAttemptedSpan = a |&gt; elements "span" |&gt; Seq.tryFind (hasClass "label label-success")
            let title, quizAttempted =
                match quizAttemptedSpan with
                | Some span -&gt;
                    title.Replace(trimAndUnescape span.InnerText, "").Trim(), true
                | None -&gt; title, false
            let videoUrl = a |&gt; attr "data-modal-iframe" 
            let lectureNotesUrl = 
                let urls = a |&gt; followingSibling "div" 
                             |&gt; elements "a" 
                             |&gt; Seq.map (attr "href") 
                match Seq.tryFind (endsWith ".pdf") urls with
                | Some url -&gt; url
                | _ -&gt; ""
            let viewed = a |&gt; parent |&gt; hasClass "viewed"
            { Id = id
              Title = title
              VideoUrl = videoUrl
              LectureNotesUrl = lectureNotesUrl
              Viewed = viewed 
              QuizAttempted = quizAttempted })
        |&gt; Seq.toArray
    { Title = title
      Completed = completed
      Lectures = lectures })
|&gt; Seq.toArray 
</code></pre>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
